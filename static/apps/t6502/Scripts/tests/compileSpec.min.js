var Tests;(function(){describe("compiler",function(){function r(n){var t="0000"+n.toString(16);return t.substring(t.length-4,t.length).toUpperCase()}var i,n,u,t;beforeEach(function(){module("app")}),beforeEach(function(){inject(function(r,f){i=r,u=f,n=i.getCpu(),t=i.getCompiler()})}),describe("given compiler when decompiler called with code",function(){beforeEach(function(){var i=new Emulator.JmpAbsolute,t=n.rPC;n.poke(n.rPC,i.opCode),n.poke(n.rPC+1,t&Constants.Memory.ByteMask),n.poke(n.rPC+2,t>>Constants.Memory.BitsInByte)}),it("then should return the decompiled code",function(){var i=t.decompile(n.rPC);expect(i).toContain("$"+r(n.rPC)+": JMP $"+r(n.rPC))})}),describe("given compiler when compile called with simple code",function(){beforeEach(function(){t.compile("JMP $"+r(n.rPC))}),it("then should compile the code at the default address",function(){var t=new Emulator.JmpAbsolute,i=[t.opCode,n.rPC&Constants.Memory.ByteMask,n.rPC>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask],r=[n.peek(n.rPC),n.peek(n.rPC+1),n.peek(n.rPC+2)];expect(JSON.stringify(r)).toEqual(JSON.stringify(i))})}),describe("given compiler when compile called with comments",function(){var n;beforeEach(function(){n=t.compile(";this is a comment     \n;this is another comment.")}),it("then should ignore the comments",function(){expect(n).toBe(!0)})}),describe("given compiler when a memory label is specified",function(){var i;beforeEach(function(){i=t.compile("$C000: JMP $C000")}),it("then should compile starting at the memory address",function(){var t=new Emulator.JmpAbsolute,r=[t.opCode,0,192],u=[n.peek(49152),n.peek(49153),n.peek(49154)];expect(i).toBe(!0),expect(JSON.stringify(u)).toEqual(JSON.stringify(r))}),it("then should set the program counter to the start address",function(){expect(n.rPC).toBe(49152)})}),describe("given compiler when a start address is specified",function(){var i;beforeEach(function(){i=t.compile("* = $C000      \nJMP $C000        ")}),it("then should set the start address to the specified address and compile the code",function(){var t=new Emulator.JmpAbsolute,r=[t.opCode,0,192],u=[n.peek(49152),n.peek(49153),n.peek(49154)];expect(i).toBe(!0),expect(JSON.stringify(u)).toEqual(JSON.stringify(r))}),it("then should set the program counter to the start address",function(){expect(n.rPC).toBe(49152)})}),describe("given compiler when a start address is specified with decimal",function(){var i;beforeEach(function(){i=t.compile("* = 49152      \nJMP 49152        ")}),it("then should set the start address to the specified address and compile the code",function(){var t=new Emulator.JmpAbsolute,r=[t.opCode,0,192],u=[n.peek(49152),n.peek(49153),n.peek(49154)];expect(i).toBe(!0),expect(JSON.stringify(u)).toEqual(JSON.stringify(r))}),it("then should set the program counter to the start address",function(){expect(n.rPC).toBe(49152)})}),describe("given compiler when source is provided with labels",function(){var i;beforeEach(function(){i=t.compile("LOOP: JMP LOOP")}),it("then should resolve the labels and compile the code using the appropriate addresses",function(){var t=new Emulator.JmpAbsolute,r=[t.opCode,n.rPC&Constants.Memory.ByteMask,n.rPC>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask],u=[n.peek(n.rPC),n.peek(n.rPC+1),n.peek(n.rPC+2)];expect(i).toBe(!0),expect(JSON.stringify(u)).toEqual(JSON.stringify(r))})}),describe("given compiler when source is provided with labels that match hex",function(){var i;beforeEach(function(){i=t.compile("ADD: JMP ADD")}),it("then should resolve the labels and compile the code using the appropriate addresses",function(){var t=new Emulator.JmpAbsolute,r=[t.opCode,n.rPC&Constants.Memory.ByteMask,n.rPC>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask],u=[n.peek(n.rPC),n.peek(n.rPC+1),n.peek(n.rPC+2)];expect(i).toBe(!0),expect(JSON.stringify(u)).toEqual(JSON.stringify(r))})}),describe("given compiler when source is provided with duplicate labels",function(){var i,r;beforeEach(function(){r=[n.peek(n.rPC),n.peek(n.rPC+1),n.peek(n.rPC+2)],i=t.compile("LOOP: JMP LOOP      \nLOOP: JMP LOOP")}),it("then should not compile and log a message to the console",function(){expect(i).toBe(!1);var t=[n.peek(n.rPC),n.peek(n.rPC+1),n.peek(n.rPC+2)];expect(JSON.stringify(t)).toBe(JSON.stringify(r))})}),describe("given compiler when source is provided with invalid op codes",function(){var i,r;beforeEach(function(){r=[n.peek(n.rPC),n.peek(n.rPC+1),n.peek(n.rPC+2)],i=t.compile("BLEH $C000")}),it("then should not compile and log a message to the console",function(){expect(i).toBe(!1);var t=[n.peek(n.rPC),n.peek(n.rPC+1),n.peek(n.rPC+2)];expect(JSON.stringify(t)).toBe(JSON.stringify(r))})}),describe("given compiler when a return from subroutine is specified",function(){var i;beforeEach(function(){i=t.compile("* = 49152      \nRTS        ")}),it("then should set the RTS op code at the memory location",function(){var t=new Emulator.RtsSingle;expect(i).toBe(!0),expect(n.peek(49152)).toEqual(t.opCode)}),it("then should set the program counter to the start address",function(){expect(n.rPC).toBe(49152)})}),describe("given compiler when immediate mode is specified",function(){var i,r=new Emulator.LoadAccumulatorImmediate;beforeEach(function(){i=t.compile("LDA #$0A   \nLDA #22   ; this is a comment")}),it("then should handle a hex value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(10)}),it("then should handle the decimal value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC+2)).toBe(r.opCode),expect(n.peek(n.rPC+3)).toBe(22)})}),describe("given compiler when immediate mode is specified",function(){describe("when high byte is specified",function(){var i,r=new Emulator.LoadAccumulatorImmediate;beforeEach(function(){i=t.compile("LABEL: LDA #>LABEL")}),it("then should handle the high value of the label",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(n.rPC>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask)})}),describe("when low byte is specified",function(){var i,r=new Emulator.LoadAccumulatorImmediate;beforeEach(function(){i=t.compile("LABEL: LDA #<LABEL")}),it("then should handle the low value of the label",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(n.rPC&Constants.Memory.ByteMask)})}),describe("when label isn't defined yet",function(){var i,r=new Emulator.LoadAccumulatorImmediate;beforeEach(function(){i=t.compile("LDA #<LABEL\nLABEL:")}),it("then should handle the low value of the label",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(n.rPC+r.sizeBytes&Constants.Memory.ByteMask)})}),describe("when label is never defined",function(){var n,i=new Emulator.LoadAccumulatorImmediate;beforeEach(function(){n=t.compile("LDA #<NOLABEL")}),it("then should not compile",function(){expect(n).toBe(!1)})})}),describe("given compiler when immediate mode is specified with invalid value",function(){var n;beforeEach(function(){n=t.compile("LDA #$AAB")}),it("then should not compile",function(){expect(n).toBe(!1)})}),describe("given compiler when absolute mode is specified",function(){var i,r=new Emulator.IncAbsolute;beforeEach(function(){i=t.compile("INC $c000   \nINC 49152   ; this is a comment")}),it("then should handle a hex value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(0),expect(n.peek(n.rPC+2)).toBe(192)}),it("then should handle the decimal value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC+3)).toBe(r.opCode),expect(n.peek(n.rPC+4)).toBe(0),expect(n.peek(n.rPC+5)).toBe(192)})}),describe("given compiler when zero page is specified",function(){var i,r=new Emulator.StoreAccumulatorZeroPage;beforeEach(function(){i=t.compile("STA $01   \nSTA 254   ")}),it("then should handle a hex value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(1)}),it("then should handle the decimal value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC+2)).toBe(r.opCode),expect(n.peek(n.rPC+3)).toBe(254)})}),describe("given compiler when immediate mode is specified with invalid value",function(){var n;beforeEach(function(){n=t.compile("LDA $C0000")}),it("then should not compile",function(){expect(n).toBe(!1)})}),describe("given compiler when absolute mode with X index is specified",function(){var i,r=new Emulator.IncAbsoluteX;beforeEach(function(){i=t.compile("INC $c000, X   \nINC 49152, X   ; this is a comment")}),it("then should handle a hex value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(0),expect(n.peek(n.rPC+2)).toBe(192)}),it("then should handle the decimal value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC+3)).toBe(r.opCode),expect(n.peek(n.rPC+4)).toBe(0),expect(n.peek(n.rPC+5)).toBe(192)})}),describe("given compiler when absolute mode with X index using label is specified",function(){var i,r=new Emulator.IncAbsoluteX;beforeEach(function(){i=t.compile("LABEL: INC LABEL, X")}),it("then should handle the label",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(n.rPC&Constants.Memory.ByteMask),expect(n.peek(n.rPC+2)).toBe(n.rPC>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask)})}),describe("given compiler when absolute mode with X index using future label is specified",function(){var r,i=new Emulator.IncAbsoluteX;beforeEach(function(){r=t.compile("INC LABEL, X\nLABEL:")}),it("then should handle the label",function(){expect(r).toBe(!0),expect(n.peek(n.rPC)).toBe(i.opCode),expect(n.peek(n.rPC+1)).toBe(n.rPC+i.sizeBytes&Constants.Memory.ByteMask),expect(n.peek(n.rPC+2)).toBe(n.rPC+i.sizeBytes>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask)})}),describe("given compiler when absolute mode with X index is specified with invalid value",function(){var n;beforeEach(function(){n=t.compile("INC $C0000, X")}),it("then should not compile",function(){expect(n).toBe(!1)})}),describe("given compiler when absolute mode with Y index is specified",function(){var i,r=new Emulator.StoreAccumulatorAbsoluteY;beforeEach(function(){i=t.compile("STA $c000, Y   \nSTA 49152,Y   ; this is a comment")}),it("then should handle a hex value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(0),expect(n.peek(n.rPC+2)).toBe(192)}),it("then should handle the decimal value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC+3)).toBe(r.opCode),expect(n.peek(n.rPC+4)).toBe(0),expect(n.peek(n.rPC+5)).toBe(192)})}),describe("given compiler when absolute mode with Y index is specified with invalid value",function(){var n;beforeEach(function(){n=t.compile("STA $C0000, Y")}),it("then should not compile",function(){expect(n).toBe(!1)})}),describe("given compiler when branch with address encountered",function(){var i,r=new Emulator.BranchNotEqualRelative;beforeEach(function(){i=t.compile("$c000: BNE $C000")}),it("then should compile to correct branch",function(){expect(i).toBe(!0),expect(n.peek(49152)).toBe(r.opCode),expect(n.peek(49153)).toBe(254)})}),describe("given compiler when branch with label encountered",function(){var i,r=new Emulator.BranchNotEqualRelative;beforeEach(function(){i=t.compile("LABEL: BNE LABEL")}),it("then should compile to correct branch",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(254)})}),describe("given compiler when branch with future label encountered",function(){var i,r=new Emulator.BranchNotEqualRelative;beforeEach(function(){i=t.compile("BNE LABEL\nLABEL:")}),it("then should compile to correct branch",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(0)})}),describe("given compiler when indexed indirect x encountered",function(){var i,r=new Emulator.ExclusiveOrIndirectX;beforeEach(function(){i=t.compile("EOR ($44,X)")}),it("then should compile to correct code",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(68)})}),describe("given compiler when indirect indexed y encountered",function(){var i,r=new Emulator.StoreAccumulatorIndirectY;beforeEach(function(){i=t.compile("STA ($44),Y")}),it("then should compile to correct code",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(68)})}),describe("given compiler when indirect mode is specified",function(){var i,r=new Emulator.JmpIndirect;beforeEach(function(){i=t.compile("JMP ($c000)   \nJMP (49152)   ; this is a comment")}),it("then should handle a hex value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(0),expect(n.peek(n.rPC+2)).toBe(192)}),it("then should handle the decimal value",function(){expect(i).toBe(!0),expect(n.peek(n.rPC+3)).toBe(r.opCode),expect(n.peek(n.rPC+4)).toBe(0),expect(n.peek(n.rPC+5)).toBe(192)})}),describe("given compiler when indirect mode using label is specified",function(){var i,r=new Emulator.JmpIndirect;beforeEach(function(){i=t.compile("LABEL: JMP (LABEL)")}),it("then should handle the label",function(){expect(i).toBe(!0),expect(n.peek(n.rPC)).toBe(r.opCode),expect(n.peek(n.rPC+1)).toBe(n.rPC&Constants.Memory.ByteMask),expect(n.peek(n.rPC+2)).toBe(n.rPC>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask)})}),describe("given compiler when indirect mode using future label is specified",function(){var r,i=new Emulator.JmpIndirect;beforeEach(function(){r=t.compile("JMP (LABEL)\nLABEL:")}),it("then should handle the label",function(){expect(r).toBe(!0),expect(n.peek(n.rPC)).toBe(i.opCode),expect(n.peek(n.rPC+1)).toBe(n.rPC+i.sizeBytes&Constants.Memory.ByteMask),expect(n.peek(n.rPC+2)).toBe(n.rPC+i.sizeBytes>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask)})}),describe("given compiler when indirect mode is specified with invalid value",function(){var n;beforeEach(function(){n=t.compile("JMP ($C0000)")}),it("then should not compile",function(){expect(n).toBe(!1)})}),describe("given compiler when label math encountered",function(){var i;beforeEach(function(){i=t.compile("main: LDA #$12 \nac_value = main + 5\nLDA #<ac_value\nLDA #>ac_value\n")}),it("then should compile and update the label accordingly",function(){expect(i).toBe(!0),expect(n.peek(n.rPC+3)).toBe(5),expect(n.peek(n.rPC+5)).toBe(n.rPC>>Constants.Memory.BitsInByte)})}),describe("given compiler when label math encountered with future label",function(){var i;beforeEach(function(){i=t.compile("ac_value = main + 5\nmain: LDA #$12 \nLDA #<ac_value\nLDA #>ac_value\n")}),it("then should compile and update the label accordingly",function(){expect(i).toBe(!0),expect(n.peek(n.rPC+3)).toBe(5),expect(n.peek(n.rPC+5)).toBe(n.rPC>>Constants.Memory.BitsInByte)})})})})(Tests||(Tests={}))