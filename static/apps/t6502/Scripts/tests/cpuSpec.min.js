var Tests;(function(){describe("cpu",function(){function u(){n.poke(512,3),n.poke(513,0),n.poke(514,2)}function e(t){return Boolean(n.rP&t)}var n,r,o,t=110,s=136,i=4660,h=257,f=65537;beforeEach(function(){module("app")}),beforeEach(function(){inject(function(t,i,u){r=t,o=i,n=new Emulator.Cpu(r,o,u)})}),afterEach(function(){n.stop()}),describe("given cpu when constructed",function(){it("then should set all default registers",function(){expect(n.rA).toBe(0),expect(n.rX).toBe(0),expect(n.rY).toBe(0),expect(n.rP).toBe(0),expect(n.rPC).toBe(Constants.Memory.DefaultStart),expect(n.rSP).toBe(Constants.Memory.Stack)}),it("then should reset all timer information",function(){expect(n.started).toBe(null),expect(n.elapsedMilliseconds).toBe(0),expect(n.instructionsPerSecond).toBe(0)}),it("then should reset running and error states",function(){expect(n.runningState).toBe(!1),expect(n.errorState).toBe(!1)}),it("then should log to the console",function(){expect(r.lines.length).toBe(1)})}),describe("given cpu that is running when stop called",function(){beforeEach(function(){u()}),it("then should set running state to false",function(){n.run();var t=!1;runs(function(){setTimeout(function(){n.stop(),t=!0},10)}),waitsFor(function(){return t},"Failed to stop the cpu.",1e3),runs(function(){expect(n.runningState).toBe(!1)})})}),describe("given cpu that is running when halt called",function(){var t;beforeEach(function(){u(),n.run();var i=!1;runs(function(){setTimeout(function(){t=r.lines.length,n.halt(),i=!0},10)}),waitsFor(function(){return i},"Failed to stop the cpu.",1e3)}),it("then should set running state to false",function(){expect(n.runningState).toBe(!1)}),it("then should set error state to true",function(){expect(n.errorState).toBe(!0)}),it("then should log the halt to the console",function(){expect(r.lines.length).toBeGreaterThan(t)})}),describe("given cpu that is running when run called",function(){it("then logs to the console that the cpu is already running",function(){var i,t;u(),i=r.lines.length,n.run(),t=r.lines.length,expect(t).toBe(i),n.run(),expect(r.lines.length).toBe(t+1),n.stop()})}),describe("given cpu in error state when run called",function(){it("then logs to the console that the cpu cannot run",function(){var t=r.lines.length;u(),n.errorState=!0,n.run(),expect(r.lines.length).toBe(t+1),expect(n.runningState).toBe(!1)})}),describe("given cpu in valid state when run called",function(){beforeEach(function(){u(),n.run()}),afterEach(function(){n.stop()}),it("then should set running state to true",function(){expect(n.runningState).toBe(!0)})}),describe("given cpu with stack available when stackPush called",function(){var i;beforeEach(function(){i=n.stackPush(t)}),it("then should return true",function(){expect(i).toBe(!0)}),it("then should update the stack pointer",function(){expect(n.rSP).toBe(255)})}),describe("given cpu with no stack available when stackPush called",function(){beforeEach(function(){n.rSP=-1}),it("then should throw an exception",function(){expect(function(){n.stackPush(t)}).toThrow()})}),describe("given cpu with information on stack when stackPop called",function(){beforeEach(function(){n.stackPush(t),n.stackPush(s)}),it("then should return the last value on the stack",function(){var t=n.stackPop();expect(t).toBe(s)})}),describe("given cpu with no information on stack when stackPop called",function(){it("then should throw an exception",function(){expect(function(){var t=n.stackPop()}).toThrow()})}),describe("given cpu with address on stack when stackRts called",function(){beforeEach(function(){var t=i-1;n.stackPush(t>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask),n.stackPush(t&Constants.Memory.ByteMask)}),it("then should set the program counter to 1 more than the address that was popped",function(){n.stackRts(),expect(n.rPC).toBe(i)})}),describe("given cpu when addressPop called",function(){beforeEach(function(){n.poke(n.rPC,t)}),it("then should pop the value at that address",function(){var i=n.addrPop();expect(i).toBe(t)})}),describe("given cpu when addressPopWord called",function(){beforeEach(function(){n.poke(n.rPC,i&Constants.Memory.ByteMask),n.poke(n.rPC+1,i>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask)}),it("then should pop the word at that address",function(){var t=n.addrPopWord();expect(t).toBe(i)})}),describe("given cpu when poke called with invalid address",function(){beforeEach(function(){n.poke(f,t)}),it("then should mask the invalid address to the valid range and set the address to the value",function(){var i=n.peek(f&Constants.Memory.Max);expect(i).toBe(t)})}),describe("given cpu when poke called with valid address",function(){beforeEach(function(){n.poke(i,t)}),it("then should set the address to the value",function(){var r=n.peek(i);expect(r).toBe(t)})}),describe("given cpu when poke called with invalid value",function(){beforeEach(function(){n.poke(i,h)}),it("then should mask the value to the valid range and set the address to the masked value",function(){var t=n.peek(i);expect(t).toBe(h&Constants.Memory.ByteMask)})}),describe("given cpu when peek called with invalid address",function(){beforeEach(function(){n.poke(f,t)}),it("then should mask the address to a valid range and return the byte at the masked address",function(){var i=n.peek(f);expect(i).toBe(t)})}),describe("given cpu when peek called with valid address",function(){beforeEach(function(){n.poke(i,t)}),it("then should return the value at that address",function(){var r=n.peek(i);expect(r).toBe(t)})}),describe("special memory scenarios",function(){describe("given cpu when display memory address is updated",function(){beforeEach(function(){n.poke(Constants.Display.DisplayStart+2,t)}),it("then should update the display with the corresponding value",function(){var n=o.pixels[2];expect(n).toBe(t)})}),describe("given cpu when peek called at the memory address of the random number generator",function(){it("then should return a random value between 0 and 255",function(){for(var t=[],i,r=0;r<10;r++)i=n.peek(Constants.Memory.ZeroPageRandomNumberGenerator),expect(i).toBeGreaterThan(-1),expect(i).toBeLessThan(256),t.push(i);t.sort(),expect(t[0]).toNotBe(t[t.length-1])})})}),describe("given value with negative bit set when setFlags called",function(){beforeEach(function(){n.setFlags(s)}),it("then should set the negative flag",function(){expect(e(Constants.ProcessorStatus.NegativeFlagSet)).toBe(!0)})}),describe("given value with negative bit not set when setFlags called",function(){beforeEach(function(){n.setFlags(t)}),it("then should reset the negative flag",function(){expect(e(Constants.ProcessorStatus.NegativeFlagSet)).toBe(!1)})}),describe("given zero value when setFlags called",function(){beforeEach(function(){n.setFlags(0)}),it("then should set the zero flag",function(){expect(e(Constants.ProcessorStatus.ZeroFlagSet)).toBe(!0)})}),describe("given non-zero value when setFlags called",function(){beforeEach(function(){n.setFlags(t)}),it("then should reset the zero flag",function(){expect(e(Constants.ProcessorStatus.ZeroFlagSet)).toBe(!1)})}),describe("given value without overflow when compareWithFlags called",function(){}),describe("given value with overflow when compareWithFlags called",function(){}),describe("given non-matching values when compareWithFlags called",function(){}),describe("given matching values when compareWithFlags called",function(){}),describe("given value greater than register when compareWithFlags called",function(){}),describe("given value less than register when compareWithFlags called",function(){}),describe("given op code value when getOperation called",function(){})})})(Tests||(Tests={}))