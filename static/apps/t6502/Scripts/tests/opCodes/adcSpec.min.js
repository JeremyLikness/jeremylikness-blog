var Tests;(function(){describe("ADC - Add with Carry",function(){var o,n,h,t,f=80,e=5,s=32,i=16,r=32,u=49152;beforeEach(function(){module("app")}),beforeEach(function(){inject(function(t,i){o=t,h=i,n=o.getCpu()})}),describe("ADC Immediate",function(){beforeEach(function(){t=new Emulator.AddWithCarryImmediate,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!1)}),describe("given not decimal mode and no carry flag set",function(){beforeEach(function(){n.poke(n.rPC,70),n.rA=88,t.execute(n)}),it("then should add the numbers and keep carry flag clear",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!1),expect(n.rA).toBe(158)})}),describe("given not decimal mode and carry flag set",function(){beforeEach(function(){n.poke(n.rPC,70),n.rA=88,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!0),t.execute(n)}),it("then should add the numbers and reset the carry flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!1),expect(n.rA).toBe(159)})}),describe("given not decimal mode and addition results in carry",function(){beforeEach(function(){n.poke(n.rPC,254),n.rA=2,t.execute(n)}),it("then should add the numbers and set the carry flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!0),expect(n.rA).toBe(256&Constants.Memory.ByteMask)})}),describe("given no unsigned carry but signed overflow",function(){beforeEach(function(){n.poke(n.rPC,80),n.rA=80,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!1),t.execute(n)}),it("then should add the numbers and set the overflow flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.OverflowFlagSet)).toBe(!0),expect(n.rA).toBe(160)})}),describe("given unsigned carry and signed overflow",function(){beforeEach(function(){n.poke(n.rPC,208),n.rA=144,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!1),t.execute(n)}),it("then should add the numbers and set the carry and set the overflow flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.OverflowFlagSet)).toBe(!0),expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!0),expect(n.rA).toBe(96)})}),describe("given decimal mode and no carry flag set",function(){beforeEach(function(){n.poke(n.rPC,34),n.rA=34,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!0),t.execute(n)}),it("then should add the numbers and keep the carry flag clear",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!1),expect(n.rA).toBe(68)})}),describe("given decimal mode and carry flag set",function(){beforeEach(function(){n.poke(n.rPC,34),n.rA=34,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!0),n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!0),t.execute(n)}),it("then should add the numbers and reset the carry flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!1),expect(n.rA).toBe(69)})}),describe("given decimal mode and addition that carries",function(){beforeEach(function(){n.poke(n.rPC,70),n.rA=88,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!0),t.execute(n)}),it("then should add the numbers and set the carry flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!0),expect(n.rA).toBe(4)})})}),describe("ADC Zero Page",function(){beforeEach(function(){t=new Emulator.AddWithCarryZeroPage,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!1)}),describe("Given a zero page address",function(){beforeEach(function(){n.poke(n.rPC,f),n.poke(f,i),n.rA=r,t.execute(n)}),it("then should add the number at the address",function(){expect(n.rA).toBe(i+r)})})}),describe("ADC Zero Page, X",function(){beforeEach(function(){t=new Emulator.AddWithCarryZeroPageX,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!1)}),describe("Given a zero page address and X offset",function(){beforeEach(function(){n.poke(n.rPC,f),n.poke(f+e,i),n.rA=r,n.rX=e,t.execute(n)}),it("then should add the number at the address computed with the X offset",function(){expect(n.rA).toBe(i+r)})})}),describe("ADC Absolute",function(){beforeEach(function(){t=new Emulator.AddWithCarryAbsolute,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!1)}),describe("Given an absolute address",function(){beforeEach(function(){n.poke(n.rPC,u&Constants.Memory.ByteMask),n.poke(n.rPC+1,u>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask),n.poke(u,i),n.rA=r,t.execute(n)}),it("then should add the number at the address",function(){expect(n.rA).toBe(i+r)})})}),describe("ADC Absolute X",function(){beforeEach(function(){t=new Emulator.AddWithCarryAbsoluteX,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!1)}),describe("Given an absolute address and X offset",function(){beforeEach(function(){n.poke(n.rPC,u&Constants.Memory.ByteMask),n.poke(n.rPC+1,u>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask),n.poke(u+e,i),n.rA=r,n.rX=e,t.execute(n)}),it("then should add the number at the address adjusted by the X offset",function(){expect(n.rA).toBe(i+r)})})}),describe("ADC Absolute Y",function(){beforeEach(function(){t=new Emulator.AddWithCarryAbsoluteY,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!1)}),describe("Given an absolute address and Y offset",function(){beforeEach(function(){n.poke(n.rPC,u&Constants.Memory.ByteMask),n.poke(n.rPC+1,u>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask),n.poke(u+s,i),n.rA=r,n.rY=s,t.execute(n)}),it("then should add the number at the address adjusted by the Y offset",function(){expect(n.rA).toBe(i+r)})})}),describe("ADC Indexed Indirect X",function(){beforeEach(function(){t=new Emulator.AddWithCarryIndexedIndirectX,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!1)}),describe("Given a zero page address and X offset",function(){beforeEach(function(){n.poke(n.rPC,f),n.poke(f+e,u&Constants.Memory.ByteMask),n.poke(f+e+1,u>>Constants.Memory.BitsInByte&Constants.Memory.ByteMask),n.poke(u,i),n.rA=r,n.rX=e,t.execute(n)}),it("then should locate the address at the zero page offset and use the value at that address to add",function(){expect(n.rA).toBe(i+r)})})})})})(Tests||(Tests={}))